#!/usr/bin/env python
import rospy
import math
import tf
import PyKDL 
import tf2_ros
import geometry_msgs.msg
from tf.transformations import *
import numpy as np

if __name__ == '__main__':

    rospy.init_node('rot_trans')

    vel_pub = rospy.Publisher('/mover/cart_vel', geometry_msgs.msg.Twist, queue_size=1)

    #Listen to transforms
    tfBuffer = tf2_ros.Buffer()
    listener = tf2_ros.TransformListener(tfBuffer)
    #t0 = (rospy.Time.now()).to_sec()

    rate = rospy.Rate(100.0) 

    old_angles_x = 0.00
    old_angles_y = 0.00
    old_angles_z = 0.00

    moved_x = 0
    moved_y = 0
    moved_z = 0

    count=0

    while not rospy.is_shutdown():

        try:
            ee2b = tfBuffer.lookup_transform('panda_link0', 'sim_end_effector', rospy.Time())
            g2b = tfBuffer.lookup_transform('panda_link0', 'goal', rospy.Time())

        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
            rate.sleep()
            continue

        #Initialization
    	vel_msg = geometry_msgs.msg.Twist()

        vel_msg.linear.x = 0.0
        vel_msg.linear.y = 0.0
        vel_msg.linear.z = 0.0

        vel_msg.angular.x = 0.0
        vel_msg.angular.y = 0.0
        vel_msg.angular.z = 0.0

        ##################################################################################################################################################################
        
        #Calculation of LINEAR Differences (goal = sim_end_effector)

        diff_x = -ee2b.transform.translation.x + g2b.transform.translation.x
        diff_y = -ee2b.transform.translation.y + g2b.transform.translation.y
        diff_z = -ee2b.transform.translation.z + g2b.transform.translation.z

        print('g2b transforms are: ', g2b.transform.translation.x, g2b.transform.translation.y, g2b.transform.translation.z, g2b.transform.rotation.x, g2b.transform.rotation.y, g2b.transform.rotation.z, g2b.transform.rotation.w)

        max_time_trans = 0.14
        r = np.sqrt(diff_x**2 + diff_y**2 + diff_z**2)
        d_t = r / max_time_trans

        if ((round(diff_x,3) != 0.000) or (round(diff_y,3) != 0.000) or (round(diff_z,3) != 0.000)):
            vel_msg.linear.x = round(diff_x,3)/d_t
            vel_msg.linear.y = round(diff_y,3)/d_t
            vel_msg.linear.z = round(diff_z,3)/d_t
            vel_pub.publish(vel_msg)
            print ('Moving with speeds along X,Y & Z: ', vel_msg.linear.x,vel_msg.linear.y, vel_msg.linear.z)
        else:
            vel_msg.linear.x = 0.0
            vel_msg.linear.y = 0.0
            vel_msg.linear.z = 0.0
            vel_pub.publish(vel_msg)
            print('No translational movement required!')
            print('Final translational differences are: ', diff_x, diff_y, diff_z)

        
        #################################################################################################################################################################
        
        #Calculation of ANGLES to be rotated (goal = end_effector)
        
        #Current Rotation Angles
        q_current = PyKDL.Rotation.Quaternion(ee2b.transform.rotation.x,ee2b.transform.rotation.y,ee2b.transform.rotation.z,ee2b.transform.rotation.w)
        current_angle = q_current.GetRPY()

        #Final Rotation Angles
        q_goal = PyKDL.Rotation.Quaternion(g2b.transform.rotation.x,g2b.transform.rotation.y,g2b.transform.rotation.z,g2b.transform.rotation.w)

        #Calculation of Angular Differences in Quaternion
        q = q_goal*q_current.Inverse()
        difference_angle = q.GetRPY()
        diff_angles  = list(difference_angle)
       
        print('Difference angles:', diff_angles)
    
        #ROTATE THE ARM (Error threshold = 0.01)
        if ( (round(diff_angles[0],3) != 0.00 ) or (round(diff_angles[1],2) != 0.00) or (round(diff_angles[2],3) != 0.015) ):
            count = count + 1
            print('Movement required!')

            max_time_rot = 0.7
            d_t = max([np.fabs(diff_angles[0])/max_time_rot,np.fabs(diff_angles[1])/max_time_rot,np.fabs(diff_angles[2])/max_time_rot]) #in seconds 

            #x compensation
            if (round(diff_angles[0],3) != 0.00 ):
                vel_msg.angular.x = (round(diff_angles[0],2))/d_t
                if (abs(round(vel_msg.angular.x,2)) <= 0.02):
                    vel_msg.angular.x = 0.00
                    print('Speed too small for X movement!')
                else:
                    print("Moving about X with speed:", vel_msg.angular.x)
                #moved_x = vel_msg.angular.x * d_t
            else: 
                vel_msg.angular.x = 0
                #moved_x = 0
            
            #y compensation
            if (round(diff_angles[1], 2) != 0.00):
                vel_msg.angular.y = diff_angles[1]/d_t
                if (abs(round(vel_msg.angular.y,3)) <= 0.005):
                    vel_msg.angular.y = 0.00
                    print('Speed too small for Y movement!')
                else:
                    print("Moving about Y with speed:", vel_msg.angular.y)
                #moved_y = vel_msg.angular.y * d_t 
            else:
                vel_msg.angular.y = 0
                #moved_y = 0

            #z compensation
            if (round(diff_angles[2], 3) != 0.015):
                vel_msg.angular.z = (-0.015 + round(diff_angles[2],3))/d_t
                if (round(vel_msg.angular.z,2) == 0.00):
                    vel_msg.angular.z = 0.00
                    print('Speed too small for Z movement!')
                else:
                    print("Moving about Z with speed:", vel_msg.angular.z)
                #moved_z = vel_msg.angular.z * d_t 
            else:
                vel_msg.angular.z = 0
                #moved_z = 0

            if (count > 1):
                print('Count of this iteration:', count)
                moved_x = old_angles_x - diff_angles[0]
                moved_y = old_angles_y - diff_angles[1]
                moved_z = old_angles_z - diff_angles[2]
                print('The angles moved in ', count - 1, ' iteration were:', moved_x, moved_y, moved_z)

            vel_pub.publish(vel_msg)

            old_angles_x = diff_angles[0]
            old_angles_y = diff_angles[1]
            old_angles_z = diff_angles[2]
            
        else: 
            #Stop the movement
            vel_msg.angular.x = 0.0
            vel_msg.angular.y = 0.0
            vel_msg.angular.z = 0.0
            vel_pub.publish(vel_msg)
            #print("Required movement completed!")
        
        rate.sleep()


        


